"""
Tic Tac Toe Player
"""

import math
import copy

X = "X"
O = "O"
EMPTY = None


def initial_state():
    """
    Returns starting state of the board.
    """
    return [[EMPTY, EMPTY, EMPTY],
            [EMPTY, EMPTY, EMPTY],
            [EMPTY, EMPTY, EMPTY]]


def player(board):
    """
    Returns player who has the next turn on a board.
    """
    turns = 0
    for i in board:
        for h in i:
            if h != EMPTY:
                turns += 1
    
    #If Terminal Board, return None
    if turns == 9:
        return None

    #if Even number of turns have been taken, it must be X's turn    
    if turns % 2 == 0:
        return X
    
    #If not an even number of turns, it must b O's turn
    else:
        return O


def actions(board):
    """
    Returns set of all possible actions (i, j) available on the board.
    """
    
    #check to see if the board is terminal
    if player(board) == None:
        return None

    else:
        returnSet = set()
        row = 0
        cell = 0
        #loop through each row
        for i in board:
            #loop through each entry in i row
            for h in i:
                #if the cell is empty, add the current row and cell to a tuple in the return set
                if h == EMPTY:
                    returnSet.add((row,cell))
                #after checking each cell, increment the current cell    
                cell += 1
            #after checking each row, increment the current row
            row += 1
            #set cell back to 0 before moving to next row
            cell =0
        return returnSet
        
                    



def result(board, action):
    """
    Returns the board that results from making move (i, j) on the board.
    """
    turn = player(board)
    
    row = 0
    cell = 0

    #create a new board with the current board's state
    newBoard = copy.deepcopy(board)

    #loop through each row in the current board
    for i in board:
        #loop through each cell in the current row
        for h in i:
            #if the row and cell match the selected action...
            if (row,cell) == action:
                #if h is not empty, the space has already been taken. Invalid move
                if h != EMPTY:
                    raise Exception
                #if h is empty, change the value to the current player's token in newBoard
                if h == EMPTY:
                    newBoard[row][cell] = turn

                    #return the new board state
                    return newBoard
            #If the cell does not match the action, continue to the next one on the next iteration
            else:
                cell += 1
        #if the row does not match the action, continue to the next one on the next iteration.
        row += 1
        #reset cell value 
        cell = 0
            
                



def winner(board):
    """
    Returns the winner of the game, if there is one.
    """
    
    cell = 0

    #check horizontal
    for i in board:

        if i[0] == i[1] == i[2] != EMPTY:
            return i[0]
    
    #check vertical
    for i in board[0]:
        if i == board[1][cell] == board[2][cell] != EMPTY:
            return board[1][cell]
        cell +=1

    cell = 0

    #check diagonals

    #Top --> Bottom diagonal
    if board[0][0] == board[1][1] == board[2][2] != EMPTY:
        return board[0][0]

    #Bottom --> Top diagonal
    if board[2][0] == board[1][1] == board[0][2] != EMPTY:
        return board[2][0]

            



def terminal(board):
    """
    Returns True if game is over, False otherwise.
    """

    turns = 0
    if winner(board) != EMPTY:
        return True
    
    for i in board:
        for h in i:
            if h != EMPTY:
                turns +=1
    if turns == 9:
        return True 
    
    else:
        return False


def utility(board):
    """
    Returns 1 if X has won the game, -1 if O has won, 0 otherwise.
    """
    if winner(board) == X:
        return 1
    if winner(board) == O:
        return -1
    else:
        return 0

def max_value(board):
    '''
    Helper function for minimax(). Returns the maximum utility number and corresponding action generated by the min_value() function. Runs recursively coupled with min_value() until the base case is hit.
    '''
    copy_board = copy.deepcopy(board)
    #Check for base case (terminal board)
    if terminal(copy_board):
        return (utility(copy_board), None)
    else:
        v = -99
        best_action = None
        #Checks all possible actions recursively and obtains the most optimal action and its utility number
        for possible_action in actions(copy_board):
            possible_v, possible_best = min_value(result(copy_board, possible_action))
            if v < possible_v:
                v, best_action = possible_v, possible_action
        return (v, best_action)

def min_value(board):
    '''
    Helper function for minimax(). Returns the minimum utility number and corresponding action generated by the max_value() function. Runs recursively coupled with max_value() until the base case is hit.
    '''
    copy_board = copy.deepcopy(board)
    #Check for base case (terminal board)
    if terminal(copy_board):
        return (utility(copy_board), None)
    else:
        v = 99
        best_action = None
        #Checks all possible actions recursively and obtains the most optimal action and its utility number
        for possible_action in actions(copy_board):
            possible_v, possible_best = max_value(result(copy_board, possible_action))
            if v > possible_v:
                v, best_action = possible_v, possible_action
        return (v, best_action)

def minimax(board):
    """
    Returns the optimal action for the current player on the board.
    """
    if player(board) == X:
        return max_value(board)[1]
    else:
        return min_value(board)[1]
    
